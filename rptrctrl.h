/* rptrctrl.h - A program to do a 'minimalist' repeater controller
 * using a Raspberry PI and simple interfacing circuitry on the
 * GPIO Port.
 *
 * This code was converted from an Arduino sketch and is only
 * intended for testing. Standard Arduino sketch functions
 * (digitalWrite, digitalRead, etc.) were replaced with
 * functions abstracting BCM2835 GPIO Library calls. These
 * are pretty close to 1:1 mapped. (Yes, I realize there is
 * a wiringPI lib).
 *
 * This implementation does not afford a separate input for a
 * tone decoder output, hence the term, 'minimalist'. To provide
 * tone access control, the receiver must have tone decoding
 * built in and the COR output must AND with this.
 *
 * The COR input and PTT output pins on the Rasberry PI GPIO port
 * are specified by defines. These should be changed to match your
 * hardware configuration/implementation.
 *
 * Currently ID audio is intended to be generated by pulsing a
 * GPIO pin which should control an off board tone generator.
 * Onboard tone generation and WAV based VOICE ID in the next version!
 *
 * Default values for the ID timer (600 Seconds - 10 minutes) and
 * the squelch tail timer (1 second) are specified by defines.
 * The runtime values of these parameters are stored in variables
 * and could be changed programatically, if desired (e.g. via the
 * serial port). Of course, you'd have to write that code.
 *
 * The ID Time out timer is implemented using the C time library and
 * is based on the elapsed time counter (unsigned long int seconds)
 * so timeout values are restricted to integer values greater than
 * one second. The squelch tail timer is implemented the same way,
 * so it has the same restrictions.
 *
 * (C) 2013-2015 KB4OID Labs - A division of Kodetroll Heavy Industries
 *
 * All rights reserved, but otherwise free to use for personal use.
 * No warranty expressed or implied.
 * This code is for educational or personal use only.
 *
 * File: rptrctrl.c
 * Date: April 22, 2013
 * Author: KB4OID/Kodetroll
 * Version: 0.85
 *
 * Build using: 'gcc -o rptrctrl rptrctrl.c  -l bcm2835 -lrt'
 *  - or -
 * just type 'make'
 *
 * NOTE: This application must be run as root to have permissions to
 * modify the GPIO pins.
 *
 * The bcm2835 gpio library from Mike McCauley is required to build this
 * application. It can be found here:
 * http://www.airspayce.com/mikem/bcm2835/
 */

#ifndef __RPTRCTRL_H__
#define __RPTRCTRL_H__

/* Make this header file easier to include in C++ code */
#ifdef __cplusplus
extern "C" {
#endif

typedef struct
{
    int version;
    const char* name;
    const char* email;
    const char* callsign;
    const char* corsense;
    const char* pttsense;
    const char* cwidspeed;
    const char* cwidfreq;
    const char* beeptype;
    const char* beepfreq1;
    const char* beepfreq2;
    const char* beeptime;
} configuration;

#define VER_MAJOR 0
#define VER_MINOR 85

#define DEBUG 0
#define DEBUG_BEEP 0
#define DEBUG_TONE 0

#define SIZE_OF_INT 4

// Blinks on RPi pin GPIO 11
#define PIN RPI_GPIO_P1_11

#define PWM_MARKSPACE 1
#define PWM_BALANCED 0
#define PWM_ON 1
#define PWM_OFF 0
#define PWM_RANGE 1024
#define PWM_DIV 16
#define PWM_CH 0
#define PWM_CLK 19200000

// Here we define the starting values of the ID and Squelch Tail
// Timers
#define DEFAULT_ID_TIMER 600       // In Seconds
#define DEFAULT_SQ_TIMER 1         // In Seconds

// other misc timer values
#define ID_PTT_DELAY  200       // in mS
#define ID_PTT_HANG   500       // in mS
#define CW_MIN_DELAY  30        // in mS
#define COR_DEBOUNCE_DELAY  50  // in mS

#define OFF LOW
#define ON HIGH

// These values define what the DIO input pin state is when this
// input is active or not. These two cases are inverses of each
// other, comment out the following define to make COR follow
// NEGATIVE logic

#define COR_POS_LOGIC 1
#define COR_NEG_LOGIC 0

//#define COR_POS_LOGIC
//#ifdef COR_POS_LOGIC
//  #define COR_ON   HIGH    // DIO Pin state when COR is active
//  #define COR_OFF  LOW     // DIO Pin state when COR is not active
//#else
//  #define COR_ON   LOW     // DIO Pin state when COR is active
//  #define COR_OFF  HIGH    // DIO Pin state when COR is not active
//#endif

// These values define what the DIO output pin state is when this
// output is active or not. These two cases are inverses of each
// other, comment out the following define to make PTT follow
// NEGATIVE logic

#define PTT_POS_LOGIC 1
#define PTT_NEG_LOGIC 0

//#define PTT_POS_LOGIC
//#ifdef PTT_POS_LOGIC
//  #define PTT_ON   HIGH    // DIO Pin state when PTT is active
//  #define PTT_OFF  LOW     // DIO Pin state when PTT is not active
//#else
//  #define PTT_ON   LOW     // DIO Pin state when PTT is active
//  #define PTT_OFF  HIGH    // DIO Pin state when PTT is not active
//#endif

// Master enum of state machine states
enum CtrlStates {
  CS_START,
  CS_IDLE,
  CS_DEBOUNCE_COR_ON,
  CS_PTT_ON,
  CS_PTT,
  CS_DEBOUNCE_COR_OFF,
  CS_SQT_ON,
  CS_SQT_BEEP,
  CS_SQT,
  CS_SQT_OFF,
  CS_PTT_OFF,
  CS_ID
};

enum BeepTypes {
  CBEEP_NONE,
  CBEEP_SINGLE,
  CBEEP_DEDOOP,
  CBEEP_DODEEP,
  CBEEP_DEDEEP
};

// 17.21.22
// This is where we define what DIO PINs map to what functions
//int PTT_PIN = 17;		// DIO Pin number for the PTT out - 17
//int COR_PIN = 18;		// DIO Pin number for the COR in - 18
//int COR_LED = 22;		// DIO Pin number for the undebounced COR indicator LED - 22
//int ID_PIN = 21;		// DIO Pin for the ID Audio output tone
//int PWM_PIN = 18;		// PWM Pin for the ID Audio output tone

//int pwm_div = PWM_DIV;

// This is where the callsign is mapped in dah/dit/spaces
// e.g. N0S would be 3,1,0,3,3,3,3,3,0,3,3,3,0
// Put your call here, then count the number of elements and set
// NumElements below
//int Elements[200];

//char Callsign[30];

//char cfgFile[50];

#define DEFAULT_CALLSIGN "NOCALL"
#define DEFAULT_CFGFILE "rptrctrl.cfg"

// Here's where we define some of the CW ID characteristics
//int NumElements = 0;     // This is the number of elements in the ID
//int ID_tone = 1200;       // Audio frequency of CW ID
//int BEEP_type = CBEEP_SINGLE;    // Courtesy Beep Type
//int BEEP_tone1 = 1000;    // Audio frequency of Courtesy Beep 1
//int BEEP_tone2 = 800;     // Audio frequency of Courtesy Beep 2
//int BeepDuration = 2;     // Courtesy Tone length (in CWID increments)
//int CW_TIMEBASE = 50;     // CW ID Speed (This is a delay in mS)
// (50 is about 20wpm)

//#define CBEEP_TYPE  CBEEP_SINGLE

// Timer definitions
//time_t ticks;            // Current elapsed time in seconds
//time_t IDTimer;          // next expire time for ID timer
//time_t SQTimer;          // next expire time for Squelch Tail timer

// timer reset value definitions
//int SQTimerValue;        // Squelch Tail interval time - in Seconds
//int IDTimerValue;        // ID Timer interval time - in Seconds

// rptr run states
//int nextState = 0;  // next state
//int rptrState = 0;  // current state
//int prevState = 0;  // previous state

// various DIO pin states
//int COR_Value;  // current COR value
//int pCOR_Value; // previous COR value
//int PTT_Value;  // current PTT state

// COR and PTT Logic sense
//int COR_SENSE = COR_NEG_LOGIC;
//int PTT_SENSE = PTT_POS_LOGIC;

// COR and PTT Logic sense states
//int COR_ON;
//int COR_OFF;
//int PTT_ON;
//int PTT_OFF;

//int Need_ID;   // Whether on not we need to ID (was bool)

/* Flag set by ‘--verbose’. */
static int verbose;

/* Flag set by ‘--debug’. */
static int debug;

//~~~~~~ abstraction of arduino dio commands
#define OUTPUT 1
#define INPUT 0
//#define HIGH 1
//#define LOW 0

// This functions returns the current time in seconds from start
// of UNIX epoch
time_t now(void);
// This function emulates the arduino pinMode function,
// setting the specified pin to the provided mode using
// the bcm2835 library
void pinMode(int pin,int value);
// This function emulates the arduino digitalWrite
// function, setting the specified pin to the
// provided value using the bcm2835 library
void digitalWrite(int pin,int value);
// This function emulates the arduino digitalRead
// function, returning the value of the specified
// pin using the bcm2835 library
int digitalRead(int pin);
// This function emulates the arduino analogWrite
// function, setting the specified PWM pin to the
// provided value using the bcm2835 library
void analogWrite(int pin,int value);
/* This function will turn on the CW ID key
 * pin and start the PWM timer to enable tone
 * generation.
 * Note: This is NOT a *Blocking call*
 */
void tone(int pin, int freq, int duration);
/* This function will turn off the CW ID key
 * pin and stops the PWM timer to disable tone
 * generation.
 * Note: This is NOT a *Blocking call*
 */
void noTone(int pin);
/* This function will reset the ID Timer by adding the
 * timer interval value to the current elapsed time
 */
void reset_id_timer(void);

/* This function will generate a beep of the
 * specified duration and frequency using PWM
 * (if enabled) and turn on the CW ID key
 * pin for the duration of the tone to enable
 * and external tone generator.
 * Note: This is a *Blocking call*
 */
void beep(int freq, int duration);
/* This function will play the courtesy beep.
 * Note: This is a *Blocking call*
 */
void do_cbeep(int btype);

/* this function will play the CW ID,
 * Note: This is a *BLOCKING CALL*
 */
void do_ID(void);
/* This function will print current repeater operating states
 * to the serial port. For debuggin purposes only.
 */
void show_state_info(void) ;
/* Startup info */
void Show_Start_Info(void);
void setCOR_Sense(int Sense);
void setPTT_Sense(int Sense);
char* cvt2morse(char c);
int ConvertCall(char * call);
/* One time startup init loop */
void setup(void);
void get_cor(void);
void show_msg(char * buf);
void loop1(void);
void loop(void);
static int handler(void* user, const char* section, const char* name,
                   const char* value);
int LoadConfig(char * cfile);
void header(char * name);
void copyright(void);
void version(void);
void usage(char * name);
int ParseArgs(int argc, char **argv);

#endif  // __RPTRCTRL_H__
