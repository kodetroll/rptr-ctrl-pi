rptr-ctrl-pi
=========================

DESCRIPTION
-----------
A C program (rptrctrl.c) to do a 'minimalist' repeater controller using 
a Raspberry PI and simple interfacing circuitry on the GPIO Port.

HOW TO GET
----------

To clone this repo, type:

git clone https://github.com/kodetroll/rptr-ctrl-pi.git

Alternatively, either click on the 'Download' button to download a zipfile
(master.zip) of the repository contents, or use this url:

https://github.com/kodetroll/rptr-ctrl-pi/archive/master.zip

DISCUSSION
----------
This code was converted from an Arduino sketch I wrote sometime ago 
and is only intended as a starting point test bed for testing the 
implementation method. Standard Arduino sketch functions (digitalWrite, 
digitalRead, pinMode, etc.) were replaced with functions abstracting 
calls to Mike McCauley's library for Broadcom BCM2835 GPIO. This 
functionality is pretty close to a 1:1 map. Good enough for a start,
anyway. (Yes, I realize there is a wiringPI lib for the Raspberry PI).

This implementation of a repeater controller does not afford a separate 
input for a tone decoder's output, hence the term, 'minimalist'. To 
provide tone access control, the receiver must have tone decoding
built in and the COR output from the receiver must 'AND' with this. 

Currently ID audio is intended to be generated by pulsing a GPIO pin 
which should control an off board audio tone generator. Onboard tone 
generation via PWM is a work in progress and WAV based VOICE ID may 
be in the next version!

The COR input, COR Indication, PTT output, and CWID keyer pins on the 
Rasberry PI GPIO port are specified by global defines in the source 
code. These should be changed to match your hardware configuration or
implementation. 

The default pin mappings are that the PTT output pin (PTT_PIN) is 
GPIO17, the COR input pin (CIR_PIN) is on GPIO18, the COR Indicator
(COR_LED) (illuminates an LED when COR is active) is on GPIO22 and
the CW ID Pin (ID_PIN) (gates or controls an offboard tone generator 
for the ID audio) is on GPIO21.

For testing, the COR input is simulated by a switch to ground on the 
COR input pin. An internal pull up resistor on this pin is enabled in 
the pinMode() function. The PTT is simulated by an LED and resistor to 
ground, which illuminates when PTT is active. The COR indicator LED as
well as the CW ID pin can also be an LED to ground to accomplish that 
function.

Default values for the ID timer (600 Seconds - 10 minutes) and
the squelch tail timer (1 second) are specified by defines.
The runtime values of these parameters are stored in variables
and could be changed programatically, if desired (e.g. via the
serial port). Of course, you'd have to write that code.

The ID Time out timer is implemented using the C time library and
is based on the elapsed time counter (unsigned long int seconds)
so timeout timer precision is restricted to integer values of
one second. The squelch tail timer is implemented the same way,
so it has the same restrictions.

INSTALLING
----------
See INSTALL for instructions on building the application.

LICENSE
-------
See LICENSE for licensing info

USAGE 
-----

'sudo ./rptctrl'

 * NOTE: This application must be run as root to have permissions to
   modify the GPIO pins.

SETUP
-----

There are three debug defines, DEBUG, DEBUG_BEEP, and DEBUG_TONE.
These should be set to zero. These are left over from my conversion 
from the Arduino sketch.

The default starting timer values are defined as:
 * DEFAULT_ID_TIMER - The time between CWIDs, defaults to 600 Seconds 
 * DEFAULT_SQ_TIMER - The squelch tail ON time, defaults to 1 Second 

Other misc timer values (specified in mS):
 * ID_PTT_DELAY - Time between PTT ON and start of CBEEP, defaults to 200 mS
 * ID_PTT_HANG - Amount of PTT time after CBEEP, defaults to 500 mS 
 * CW_MIN_DELAY - Minimum inter-element delay, defaults to 30 mS
 * COR_DEBOUNCE_DELAY - Amount of time COR must be present before 
   being counted as valid, defaults to 50 mS

COR and PTT logic can be specified as POSITIVE or NEGATIVE; there
are defines (COR_POSITIVE, etc) to explicitly set this. The 
defaults are COR_NEGATIVE (H to L transition, L active), and 
PTT_POSITIVE (L to H transition, H active). If these are changed,
the application must be recompiled.

You can specify 5 different types of courtesy beep (CBEEP) by changing
the value of the CBEEP_TYPE compiler define . The possible values are:
are:

| Type | Description |
| ---- | ----------- |
| CBEEP_NONE | No CBEEP |
| CBEEP_SINGLE | Single tone |
| CBEEP_DEDOOP | Two tone, hi to low frequency |
| CBEEP_DODEEP | Two tone, low to hi frequency |
| CBEEP_DEDEEP | Two tone, same frequency |

The default is CBEEP_SINGLE. The software must be recompiled for any
CBEEP changes to take effect.

The GPIO pins that control COR/PTT/COR INDICATION & CWID are definable
as well. The defaults are defined as follows:
```
PTT = 17; // DIO Pin number for the PTT out - 9
COR = 18; // DIO Pin number for the COR in - 12
CORLED = 22; // DIO Pin number for the COR indicator LED - 11
ID_PIN = 21; // DIO Pin for the ID Audio output tone
```
Change these values to map these functions to alternate GPIO pins.
These are variables, so they can be overridden or changed once the 
applicaiton starts, however, there is currently no way to do this.
If the defaults are changed, the application must be recompiled.

HOW IT WORKS
------------
This program utilizes a state machine to control the various stages
of the repeater action. These are enumerated as CtrlStates and are
(briefly):

| State Name | State Description |
| ---------- | ----------------- |
| CS_START | Starting state |
| CS_IDLE | IDLE state, waiting for COR activity |
| CS_DEBOUNCE_COR_ON | COR active sensed, waiting debounce time. |
| CS_PTT_ON | Setting PTT to active state |
| CS_PTT | PTT in active hold state |
| CS_DEBOUNCE_COR_OFF | COR dropped, going to Squelch Tail |
| CS_SQT_ON | Squelch tail activated |
| CS_SQT_BEEP | Courtesy Beep generating |
| CS_SQT | Squelch tail hold |
| CS_SQT_OFF | Setting Squelch tail to inactive |
| CS_PTT_OFF | Setting PTT to inactive |
| CS_ID | Play ID |

As the program runs, various events (changing inputs, timers, etc) cause
the program to advance from state to state. At each state, actions are 
taken (outputs changed, etc) abd the next state decided. The program is 
limited to only those states programmed.

The program layout somewhat resembles an arduino sketch. There is a 
'setup' function that resembles the similarly named arduino function,
which is run once at program start, and a 'loop' function that runs 
continiously.

During execution of the loop section, the COR state is read and a switch
statement fires a CASE (once for each state) based on the current state. 
As each state CASE is completed, the next state is defined. In this way
the program steps from state to state. Some states are transition states,
in which they are executed once and proceed immediately to the next state
with the next call of loop(). Other states are entered and the program 
will loiter there through multiple calls of loop() until some condition is 
met or reached and the state changes. Transition states may output
messages to STDOUT indicating current machine status.

SETTING UP THE CW ID
----------------
To program the CW ID callsign, you must map the dah/dit/spaces of your 
call to 'elements' in an 'int array'. The values of the 'elements' 
represent a combination of the duration of the CW ID TONE and KEY. 
A DAH element is represented by a value of '3', a DIT element is 
represented by a value of '1' and a SPACE element is represented by 
'0'. These values are chosen to indicate the relative length of the 
element, with the length of the dit and space being set the same. If 
an an element value is greater than zero, then the specified GPIO 
ID pin is active (H) and if the element value is zero, then the 
specified GPIO ID pin is (L). This can be used to key an off board 
tone generator gated into the repeater audio path. 

For example, the call 'N0S' would be DAH DIT, SPACE, DAH DAH DAH DAH DAH, 
SPACE, DAH DAH DAH. Represented as 'elements' this would be:
3,1,0,3,3,3,3,3,0,3,3,3,0

So the Elements array would look like this:
```
int Elements[] = {
  3,1,0,3,3,3,3,3,0,3,3,3,0
};
```
To set the CW ID Speed, find and change the value of CW_TIMEBASE. This 
defaults to a value of '50' mS which is about 20 WPM, give or take.
The duration of the courtesy tone beep is set by BeepDuration, which 
defaults to '2' in CWID clock increments. The two differenet CBEEP
tone frequencies are held in BEEP_tone1 and BEEP_tone2. These default
to 1000 and 800 hz, respectivly. The CWID Tone value is held in ID_tone,
and defaults to 1200 hz. These tones are generated by the PWM module of 
the bcm2835 lib and are written out to the pin specified by the value 
of ID_PIN. This signal can be mixed or injected into the repeater audio
path. Currently, changing these values will require a recompile to make 
any changes active. 



